import ast
from _ast import AST, PyCF_ONLY_AST, PyCF_TYPE_COMMENTS


class BaseModuleVisitor(ast.NodeVisitor):
    TAB = " " * 4
    DEFAULT_MODULE_DOCSTRING = """Generated by Boris v0.1"""

    symbols = {
        ast.Eq: "==",
        ast.Is: '==',
        ast.NotEq: '!=',
        ast.Pass: '/*pass*/',
        ast.Mult: '*',
        ast.Add: '+',
        ast.Sub: '-',
        ast.Div: '/',
        ast.FloorDiv: '/',
        ast.Mod: '%',
        ast.Lt: '<',
        ast.Gt: '>',
        ast.GtE: '>=',
        ast.LtE: '<=',
        ast.LShift: '<<',
        ast.RShift: '>>',
        ast.BitXor: '^',
        ast.BitOr: '|',
        ast.BitAnd: '&',
        ast.Not: '!',
        ast.IsNot: '!=',
        ast.USub: '-',
        ast.And: '&&',
        ast.Or: '||',
        ast.In: 'in',
    }

    python_type_map = {
        "int": "int",
        "float": "float",
        "bytes": "bytes",
        "str": "str",
        "tuple": "tuple",
        "dict": "dict",
        "set": "set",
        "list": "list",
    }

    python_keywords = frozenset([
        "import",
        "from",
        "as",
        "with",
        "async",
        "def",
        "yield",
        "class",
    ])

    __instructions = []

    @staticmethod
    def get_docstring(node, clean=True, default=None):
        """
        Return the docstring for the given node or None if no docstring can
        be found.  If the node provided does not have docstrings a TypeError
        will be raised.

        If *clean* is `True`, all tabs are expanded to spaces and any whitespace
        that can be uniformly removed from the second line onwards is removed.
        """
        if not isinstance(node, (ast.AsyncFunctionDef, ast.FunctionDef, ast.ClassDef, ast.Module)):
            return None
        if not (node.body and isinstance(node.body[0], ast.Expr)):
            return None
        node = node.body[0].value
        if isinstance(node, ast.Str):
            text = node.s
        elif isinstance(node, ast.Constant) and isinstance(node.value, str):
            text = node.value
        else:
            return None
        if clean:
            import inspect
            text = inspect.cleandoc(text)
        return text if not default else "%s\n%s" % (default, text)

    @staticmethod
    def python_symbol(node):
        """Find the equivalent C symbol for a Python ast symbol node"""
        symbol_type = type(node)
        return BaseModuleVisitor.symbols[symbol_type]

    def visit(self, node, level: int = 0):
        if type(node) in self.symbols:
            return self.python_symbol(node)
        else:
            """Visit a node."""
            method = 'visit_' + node.__class__.__name__
            visitor = getattr(self, method, self.generic_visit)

            """Get docstring"""
            node.docstring = self.get_docstring(
                node, default=self.DEFAULT_MODULE_DOCSTRING
            )
            return visitor(node, level)

    def generic_visit(self, node, indent: int, level: int = 0):
        """Called if no explicit visitor function exists for a node."""
        if not isinstance(node, AST):
            raise TypeError('expected AST, got %r' % node.__class__.__name__)

        def save_visited_instruction(i):
            self.__instructions.append(self.visit(i, level))

        for field, value in ast.iter_fields(node):
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, AST):
                        save_visited_instruction(item)

            elif isinstance(value, AST):
                save_visited_instruction(value)

    def transpile(self, node: ast.Module, indent=None):
        return self.generic_visit(node, indent=indent)

    @staticmethod
    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            assert major == 3
            feature_version = minor
        elif feature_version is None:
            feature_version = -1
        # Else it should be an int giving the minor version for 3.x.
        return compile(source, filename, mode, flags,
                       _feature_version=feature_version)
